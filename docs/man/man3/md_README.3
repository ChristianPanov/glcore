.TH "md_README" 3 "Fri Apr 28 2023" "GLCore" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md_README \- README 
.PP
No-dependency OpenGL support library, which abstracts the processes of creating buffers and shaders 
.SH "Install"
.PP
.PP
.nf
git clone \-\-recursive https://github\&.com/ChristianPanov/glcore
.fi
.PP
 
.SH "Design Highlights"
.PP
.IP "\(bu" 2
Very lightweight - \fI\fBglcore\fP\fP is merely a thin wrapper around the OpenGL functions, except the shader class, which is more than a wrapper\&. It may be thin, but it's very useful for abstracting the OpenGL state machine logic to a more object-oriented logic
.IP "\(bu" 2
No dependencies - \fI\fBglcore\fP\fP does not enforce any dependencies such as function loaders, by using placeholder functions, which can be replaced with the function loader of choice simply by putting the needed includes in a specific file 
.PP
.SH "Features"
.PP
.IP "\(bu" 2
Vertex buffers
.IP "\(bu" 2
Vertex buffer layout
.IP "\(bu" 2
Index buffers
.IP "\(bu" 2
Vertex arrays
.IP "\(bu" 2
Shaders 
.PP
.SH "Setup"
.PP
Because of the no-dependency nature of \fI\fBglcore\fP\fP, you will need to provide the OpenGL function loader\&.\\ To do that, you will need to locate the \fCsrc/glcore/tweakme\fP folder, and open the \fC\fI\fBgl_functions\&.h\fP\fP\fP header file\&.\\ From there on, it is pretty self explanatory with the comments that are provided in the file\&. 
.SH "Usage"
.PP
.SS "Basic Usage"
.PP
.nf
#include "glcore\&.h"

int main()
{
    float vertices[4][7] = {
        { \-0\&.5f, \-0\&.5f, 0\&.0f, 0\&.8f, 0\&.2f, 0\&.8f, 1\&.0f },
        {  0\&.5f, \-0\&.5f, 0\&.0f, 0\&.2f, 0\&.3f, 0\&.8f, 1\&.0f },
        {  0\&.5f,  0\&.5f, 0\&.0f, 0\&.8f, 0\&.8f, 0\&.2f, 1\&.0f },
        { \-0\&.5f,  0\&.5f, 0\&.0f, 0\&.8f, 0\&.8f, 0\&.2f, 1\&.0f }
    };

    unsigned int indices[2][3] = {
        { 0, 1, 2 },
        { 0, 2, 3 }
    };

    glcore::vertex_buffer vbo(*vertices, sizeof(vertices));
    glcore::index_buffer ibo(*indices, sizeof(indices) / sizeof(int));
    glcore::vertex_buffer_layout layout =
    {
        { glcore::shader_data_type::vec3, "position" },
        { glcore::shader_data_type::vec4, "color" }
    };
    vbo\&.set_layout(layout);

    glcore::vertex_array vao;
    vao\&.add_vertex_buffer(vbo);
    vao\&.set_index_buffer(ibo);

    glcore::shader_program shaders("Basic", {
        { glcore::shader_type::vertex, "shader_examples/vert\&.glsl" },
        { glcore::shader_type::fragment, "shader_examples/frag\&.glsl" }
        });
    shaders\&.bind();

    shaders\&.upload_uniform4f("u_Color", 0\&.2f, 0\&.3f, 0\&.8f, 1\&.0f);

    return 0;
}
.fi
.PP
 
.SS "Vertex buffer layout"
The vertex buffer layout is declared in a very intuitive way\&. You provide a shader data type and an identifier name\&. The shader data types reside in the \fCglcore::shader_data_type\fP namespace\&. 
.PP
.nf
glcore::vertex_buffer_layout layout =
{
    { glcore::shader_data_type::vec3, "position" },
    { glcore::shader_data_type::vec4, "color" }
};

.fi
.PP
 A vertex buffer layout can either be declared on it's own like in the example above, or can be created as an rvalue directly in the constructor of \fC\fBglcore::vertex_buffer\fP\fP 
.PP
.nf
glcore::vertex_buffer vbo(*vertices, sizeof(vertices), {
    { glcore::shader_data_type::type::vec3, "position" },
    { glcore::shader_data_type::type::vec4, "color" }
});

.fi
.PP
 
.SS "Shaders"
A shader program can be handled in two different ways\&. You can have separate shader files for each type of shader, or you can have one single shader file\&. 
.SS "Single file"
With the single file approach, you only need to provide the file path and a name for the shader program\&. If you don't provide a name for the shader program, \fI\fBglcore\fP\fP will automatically set the name to be the name of the file\&. 
.PP
.nf
glcore::shader_program shaders_single("Basic", "shader_examples/basic\&.glsl");

// the name of the shader program will be set to 'basic'
glcore::shader_program shader_single_noname("shader_examples/basic\&.glsl");

.fi
.PP
 For the shader parser to differentiate between the different shaders in the file, the shader code needs to start with a specific command line - \fC#type [shader type]\fP 
.SS "Example"
.PP
.nf
#type vertex
#version 330 core

layout(location = 0) in vec3 a_Position;

out vec3 v_Position;

void main()
{
    v_Position = a_Position;
    gl_Position = vec4(a_Position, 1\&.0);
};

#type fragment
#version 330 core

layout(location = 0) out vec4 color;

uniform vec4 u_Color;

void main()
{
    color = u_Color;
};
.fi
.PP
 
.SS "Multiple files"
With this approach, you will need to spefify the type of the shader with an enum value, which resides in the \fCglcore::shader_type\fP namespace, and a file path\&. 
.PP
.nf
glcore::shader_program shaders("Basic", {
        { glcore::shader_type::vertex, "shader_examples/vert\&.glsl" },
        { glcore::shader_type::fragment, "shader_examples/frag\&.glsl" }
        });

.fi
.PP
 
.SS "Supported types of shaders"
Shader Type   Enum Value   GLSL Command    Vertex   \fCglcore::shader_type::vertex\fP   \fC#type vertex\fP    Fragment   \fCglcore::shader_type::fragment\fP   \fC#type fragment\fP    Tessellation Control   \fCglcore::shader_type::tess_control\fP   \fC#type tess_control\fP    Tessellation Evaluation   \fCglcore::shader_type::tess_eval\fP   \fC#type tess_eval\fP    Geometry   \fCglcore::shader_type::geometry\fP   \fC#type geometry\fP   
